@using DockerGen.Container
@using System.Text
@using DockerGen.Features.Container.Store
@inject IState<ContainerState> State
@inject IDispatcher Dispatcher
<div class="@GetDropzoneClass()">
	<div class="@GetDropAreaClass() @activeClass" @ondragenter="SetActiveDrop" @ondragleave="SetInactiveDrop" @ondrop="@(() => OnDrop(0))"></div>
	<ul class="instruction-list" ondragover="event.preventDefault();">
		@foreach (var instruction in Stage.Instructions)
		{
			<DynamicComponent Type="@instruction.UIType" Parameters="GetParametersForInstruction(instruction)"></DynamicComponent>
			<div class="@GetDropAreaClass() @activeClass" @ondragenter="SetActiveDrop" @ondragleave="SetInactiveDrop" @ondrop="@(() => OnDrop(GetIndex(instruction) + 1))"></div>
		}
	</ul>
</div>

@code {
	[Parameter]
	public BuildStage Stage { get; set; }
	private string activeClass = "";

	public void AddInstruction(IInstruction instruction, int index = -1)
	{
		Dispatcher.Dispatch(new ContainerAddInstructionToStageAction(Stage, instruction, index));
	}

	private Dictionary<string, object> GetParametersForInstruction(IInstruction instruction)
	{
		var paramName = "Instruction";
		if (instruction is DynamicRecipe)
		{
			paramName = "Recipe";
		}
		return new Dictionary<string, object>
			{
				{ paramName, instruction}
			};
	}

	private string GetDropzoneClass()
	{
		if (State.Value.IsDragging)
		{
			return "dropzone-active";
		}
		return "";
	}

	private string GetDropAreaClass()
	{
		if (State.Value.IsDragging)
		{


			return "droparea";
		}
		return "";
	}

	private void SetActiveDrop()
	{
		if (CanDrop(State.Value.CurrentInstruction))
		{
			activeClass = "active";
		}
		else
		{
			activeClass = "";
		}
	}

	private void SetInactiveDrop()
	{
		activeClass = "";
	}

	private void OnDrop(int dropIndex = -1)
	{
		SetInactiveDrop();

		var instruction = State.Value.CurrentInstruction;
		if (!CanDrop(instruction))
		{
			return;
		}

		if (dropIndex == -1)
		{
			AddInstruction(instruction);
		}
		else
		{
			AddInstruction(instruction, dropIndex);
		}
		Dispatcher.Dispatch(new ContainerSetCurrentInstructionAction(null));
		Dispatcher.Dispatch(new ContainerUpdatedAction());
	}

	private bool CanDrop(IInstruction instruction)
	{
		if (instruction is FromInstruction)
		{
			return false;
		}
		else if (instruction is EntryPointInstruction && Stage.Instructions.Any(i => i is EntryPointInstruction))
		{
			return false;
		}
		else if (instruction is CommandInstruction && Stage.Instructions.Any(i => i is CommandInstruction))
		{
			return false;
		}

		return true;
	}


	private int GetIndex(IInstruction instruction)
	{
		return Stage.Instructions.FindIndex(i => i.Id == instruction.Id);
	}

	private List<string> GetBuildStageNames()
	{
		return State.Value.Container.Stages.Select(s => s.StageName).ToList();
	}
}
