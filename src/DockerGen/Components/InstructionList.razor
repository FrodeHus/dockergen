@using DockerGen.Container
@using System.Text
@using DockerGen.Features.Container.Store
@inject IState<ContainerState> State
@inject IDispatcher Dispatcher
<div class="instruction-list @GetDropzoneClass()"
     ondragstart="event.dataTransfer.setData('text', event.target.id);"
     @ondragover:preventDefault
     @ondrop:preventDefault
     @ondragenter:preventDefault
     @ondrop:stopPropagation
     @ondragenter:stopPropagation
     @ondragover:stopPropagation
     @ondragstart:stopPropagation
     @ondragleave:stopPropagation
     @ondragend:stopPropagation>
    <div class="@GetDropzoneClasses(0)" @ondrop="() => OnDrop(0)" @ondrop:stopPropagation @ondragenter="(() => DropDragEnter(0))" @ondragleave="DropDragLeave"></div>

    @foreach (var instruction in Stage.Instructions)
    {
        <div class="draggable-component" draggable="true"
         @ondragstart="() => StartDrag(instruction)"
         @ondragend="EndDrag">
            <i class="drag-handle fa fa-grip-lines"></i>
            <div class="instruction-card">
                <input type="checkbox" checked class="toggle" id="@instruction.Id">
                <div class="instruction-card__header">
                    <label for="@instruction.Id" class="lbl-toggle">@instruction.DisplayName</label>
                    <a class="btn-close-instruction" href="#" aria-label="Close" @onclick="() => RemoveInstruction(instruction)">
                        <i class="fa fa-window-close" />
                    </a>
                </div>
                <div class="instruction-card__content">
                    <DynamicComponent Type="@instruction.UIType" Parameters="GetParametersForInstruction(instruction)"></DynamicComponent>
                </div>
            </div>
        </div>
        <div class="@GetDropzoneClasses(GetIndex(instruction) + 1)" @ondrop="() => OnDrop(GetIndex(instruction)+1)" @ondrop:stopPropagation @ondragenter="(() => DropDragEnter(GetIndex(instruction)+1))" @ondragleave="DropDragLeave"></div>
    }
</div>

@code {
    [Parameter]
    public BuildStage Stage { get; set; }
    private bool IsDragging;
    public void AddInstruction(IInstruction instruction, int index = -1)
    {
        Dispatcher.Dispatch(new ContainerAddInstructionToStageAction(Stage, instruction, index));
        Dispatcher.Dispatch(new ContainerUpdatedAction());
    }

    public void RemoveInstruction(IInstruction instruction)
    {
        Dispatcher.Dispatch(new ContainerRemoveInstructionAction(instruction));
        Dispatcher.Dispatch(new ContainerUpdatedAction());
    }

    private void StartDrag(IInstruction instruction)
    {
        IsDragging = true;
        Dispatcher.Dispatch(new ContainerSetCurrentInstructionAction(instruction));
    }

    private void EndDrag()
    {
        IsDragging = false;
    }

    private Dictionary<string, object> GetParametersForInstruction(IInstruction instruction)
    {
        var paramName = "Instruction";
        if (instruction is DynamicRecipe)
        {
            paramName = "Recipe";
        }
        return new Dictionary<string, object>
    {
    { paramName, instruction}
    };
    }

    private string GetDropzoneClasses(int index)
    {
        var builder = new StringBuilder();
        if (State.Value.IsDragging || IsDragging)
            builder.Append("drag-spacing");

        if (State.Value.ItemIndex == index && Stage.StageName == State.Value.ActiveStage.StageName)
        {
            builder.Append(" drag-dragover");
            builder.Append(" drag-dragover__spacing");
        }

        return builder.ToString();
    }

    private void DropDragEnter(int index)
    {
        Dispatcher.Dispatch(new DragSetIndexAction(index));
        Dispatcher.Dispatch(new ContainerSetActiveStage(Stage));

    }

    private void DropDragLeave()
    {
        Dispatcher.Dispatch(new DragSetIndexAction(-1));
        Dispatcher.Dispatch(new ContainerSetActiveStage(null));

    }


    private string GetDropzoneClass()
    {
        if (State.Value.IsDragging)
        {
            return "dropzone-active";
        }
        return "";
    }

    private string GetDropAreaClass()
    {
        if (State.Value.IsDragging)
        {


            return "droparea";
        }
        return "";
    }


    private void OnDrop(int dropIndex = -1)
    {
        var instruction = State.Value.CurrentInstruction;
        if (instruction == null)
        {
            return;
        }
        if (!CanDrop(instruction))
        {
            return;
        }

        if (GetIndex(instruction) != -1)
        {
            RemoveInstruction(instruction);
        }

        if (dropIndex == -1)
        {
            AddInstruction(instruction);
        }
        else
        {
            AddInstruction(instruction, dropIndex);
        }
        Dispatcher.Dispatch(new DragAction(false));
        Dispatcher.Dispatch(new DragSetIndexAction(-1));
        Dispatcher.Dispatch(new ContainerSetCurrentInstructionAction(null));
        Dispatcher.Dispatch(new ContainerUpdatedAction());
    }

    private bool CanDrop(IInstruction instruction)
    {
        if (instruction is FromInstruction)
        {
            return false;
        }
        else if (instruction is EntryPointInstruction && Stage.Instructions.Any(i => i is EntryPointInstruction))
        {
            return false;
        }
        else if (instruction is CommandInstruction && Stage.Instructions.Any(i => i is CommandInstruction))
        {
            return false;
        }

        return true;
    }


    private int GetIndex(IInstruction instruction)
    {
        return Stage.Instructions.FindIndex(i => i.Id == instruction.Id);
    }

    private List<string> GetBuildStageNames()
    {
        return State.Value.Container.Stages.Select(s => s.StageName).ToList();
    }
}
