@using DockerGen.Container
@using System.Text
@using DockerGen.Features.Container.Store
@inject IState<ContainerState> State
@inject IDispatcher Dispatcher
<div class="@GetDropzoneClass()">
	<div class="@GetDropAreaClass() @activeClass" @ondragenter="SetActiveDrop" @ondragleave="SetInactiveDrop" @ondrop="@(() => OnDrop(0))"></div>
	<ul class="instruction-list" ondragover="event.preventDefault();">
		@foreach (var instruction in Stage.Instructions)
		{
			@if (instruction is FromInstruction fromImage)
			{
				<FromImage Instruction="fromImage"></FromImage>
			}
			else if (instruction is RunInstruction runCommand)
			{
				<RunCommand Instruction="runCommand"></RunCommand>
			}
			else if (instruction is CopyInstruction copyFiles)
			{
				<CopyFiles Instruction="copyFiles" BuildStages="@GetBuildStageNames()"></CopyFiles>
			}
			else if (instruction is WorkDirInstruction workdir)
			{
				<WorkDir Instruction="workdir"></WorkDir>
			}
			else if (instruction is UserInstruction user)
			{
				<User Instruction="user"></User>
			}
			else if (instruction is ExposeInstruction exposed)
			{
				<Expose Instruction="exposed"></Expose>
			}
			else if (instruction is DynamicRecipe recipe)
			{
				<InstructionRecipe Recipe="recipe"></InstructionRecipe>
			}
			else if (instruction is ArgumentInstruction argument)
			{
				<Argument Instruction="argument"></Argument>
			}
			else if(instruction is HealthCheckInstruction health){
				<HealthCheck Instruction="health"></HealthCheck>
			}
			else if(instruction is EnvironmentInstruction env){
				<EnvironmentVariable Instruction="env"></EnvironmentVariable>
			}
			else if(instruction is EntryPointInstruction entry){
				<EntryPoint Instruction="entry"></EntryPoint>
			}
			else if(instruction is CommandInstruction cmd){
				<Command Instruction="cmd"></Command>
			}
			else
			{
				<NotImplemented Instruction="instruction"></NotImplemented>
			}
			<div class="@GetDropAreaClass() @activeClass" @ondragenter="SetActiveDrop" @ondragleave="SetInactiveDrop" @ondrop="@(() => OnDrop(GetIndex(instruction) + 1))"></div>
		}
	</ul>
</div>

@code {
	[Parameter]
	public BuildStage Stage { get; set; }
	private string activeClass = "";

	public void AddInstruction(IInstruction instruction, int index = -1)
	{
		Dispatcher.Dispatch(new ContainerAddInstructionToStageAction(Stage, instruction, index));
	}

	private string GetDropzoneClass()
	{
		if (State.Value.IsDragging)
		{
			return "dropzone-active";
		}
		return "";
	}

	private string GetDropAreaClass()
	{
		if (State.Value.IsDragging)
		{


			return "droparea";
		}
		return "";
	}

	private void SetActiveDrop()
	{
		if (CanDrop(State.Value.CurrentInstruction))
		{
			activeClass = "active";
		}
		else
		{
			activeClass = "";
		}
	}

	private void SetInactiveDrop()
	{
		activeClass = "";
	}

	private void OnDrop(int dropIndex = -1)
	{
		SetInactiveDrop();

		var instruction = State.Value.CurrentInstruction;
		if (!CanDrop(instruction))
		{
			return;
		}

		if (dropIndex == -1)
		{
			AddInstruction(instruction);
		}
		else
		{
			AddInstruction(instruction, dropIndex);
		}
		Dispatcher.Dispatch(new ContainerSetCurrentInstructionAction(null));
		Dispatcher.Dispatch(new ContainerUpdatedAction());
	}

	private bool CanDrop(IInstruction instruction)
	{
		if (instruction is FromInstruction)
		{
			return false;
		}
		else if (instruction is EntryPointInstruction && Stage.Instructions.Any(i => i is EntryPointInstruction))
		{
			return false;
		}
		else if (instruction is CommandInstruction && Stage.Instructions.Any(i => i is CommandInstruction))
		{
			return false;
		}

		return true;
	}


	private int GetIndex(IInstruction instruction)
	{
		return Stage.Instructions.FindIndex(i => i.Id == instruction.Id);
	}

	private List<string> GetBuildStageNames()
	{
		return State.Value.Container.Stages.Select(s => s.StageName).ToList();
	}
}
