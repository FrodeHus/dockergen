@using DockerGen.Container
@using System.Text
@using DockerGen.Features.Container.Store
@inject IState<ContainerState> State
@inject IDispatcher Dispatcher
<div class="instruction-list @GetDropzoneClass()" ondragover="event.preventDefault()"
     @ondragover:preventDefault
     @ondrop:preventDefault
     @ondragenter:preventDefault
     @ondrop:stopPropagation
     @ondragenter:stopPropagation
     @ondragover:stopPropagation
     @ondragstart:stopPropagation
     @ondragleave:stopPropagation
     @ondragend:stopPropagation>
    <div class="@GetDropzoneClasses(0)" @ondrop="() => OnDrop(0)" @ondrop:stopPropagation @ondragenter="(() => DropDragEnter(0))" @ondragleave="DropDragLeave"></div>
    <CascadingValue Value="this">
        @foreach (var instruction in Stage.Instructions)
        {
            <DraggableComponent Instruction="instruction"></DraggableComponent>
            <div class="@GetDropzoneClasses(GetIndex(instruction) + 1)" @ondrop="() => OnDrop(GetIndex(instruction)+1)" @ondrop:stopPropagation @ondragenter="(() => DropDragEnter(GetIndex(instruction)+1))" @ondragleave="DropDragLeave"></div>
        }
    </CascadingValue>
</div>

@code {
    [Parameter]
    public BuildStage Stage { get; set; }
    private bool IsDragging;
    public void AddInstruction(IInstruction instruction, int index = -1)
    {
        Dispatcher.Dispatch(new ContainerAddInstructionToStageAction(Stage, instruction, index));
        Dispatcher.Dispatch(new ContainerUpdatedAction());
    }

    public void RemoveInstruction(IInstruction instruction)
    {
        Dispatcher.Dispatch(new ContainerRemoveInstructionAction(instruction));
        Dispatcher.Dispatch(new ContainerUpdatedAction());
    }

    private string GetDropzoneClasses(int index)
    {
        var builder = new StringBuilder();
        if (State.Value.IsDragging || IsDragging)
            builder.Append("drag-spacing");

        if (State.Value.ItemIndex == index && Stage.StageName == State.Value.ActiveStage.StageName)
        {
            builder.Append(" drag-dragover");
            builder.Append(" drag-dragover__spacing");
        }

        return builder.ToString();
    }

    private void DropDragEnter(int index)
    {
        Dispatcher.Dispatch(new DragSetIndexAction(index));
        Dispatcher.Dispatch(new ContainerSetActiveStage(Stage));

    }

    private void DropDragLeave()
    {
        Dispatcher.Dispatch(new DragSetIndexAction(-1));
        Dispatcher.Dispatch(new ContainerSetActiveStage(null));

    }


    private string GetDropzoneClass()
    {
        if (State.Value.IsDragging)
        {
            return "dropzone-active";
        }
        return "";
    }

    private string GetDropAreaClass()
    {
        if (State.Value.IsDragging)
        {


            return "droparea";
        }
        return "";
    }


    private void OnDrop(int dropIndex = -1)
    {
        var instruction = State.Value.CurrentInstruction;
        if (instruction == null)
        {
            return;
        }
        if (!CanDrop(instruction))
        {
            return;
        }

        if (GetIndex(instruction) != -1)
        {
            RemoveInstruction(instruction);
        }

        if (dropIndex == -1)
        {
            AddInstruction(instruction);
        }
        else
        {
            AddInstruction(instruction, dropIndex);
        }
        Dispatcher.Dispatch(new DragAction(false));
        Dispatcher.Dispatch(new DragSetIndexAction(-1));
        Dispatcher.Dispatch(new ContainerSetCurrentInstructionAction(null));
        Dispatcher.Dispatch(new ContainerUpdatedAction());
    }

    private bool CanDrop(IInstruction instruction)
    {
        if (instruction is FromInstruction)
        {
            return false;
        }
        else if (instruction is EntryPointInstruction && Stage.Instructions.Any(i => i is EntryPointInstruction))
        {
            return false;
        }
        else if (instruction is CommandInstruction && Stage.Instructions.Any(i => i is CommandInstruction))
        {
            return false;
        }

        return true;
    }


    private int GetIndex(IInstruction instruction)
    {
        return Stage.Instructions.FindIndex(i => i.Id == instruction.Id);
    }

    private List<string> GetBuildStageNames()
    {
        return State.Value.Container.Stages.Select(s => s.StageName).ToList();
    }
}
